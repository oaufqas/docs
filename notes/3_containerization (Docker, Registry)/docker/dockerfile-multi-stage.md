**Multi-stage builds** — это техника написания Dockerfile, которая позволяет сделать итоговый образ максимально легким (в 10-50 раз меньше оригинала), оставляя в нем только готовый скомпилированный код без «мусора» вроде компиляторов, исходников и кэша инструментов сборки.

Чтобы собрать приложение (например, на Go, Java или React), вам нужны инструменты: компиляторы, npm, maven, gcc. Все они весят сотни мегабайт. Если вы оставите их в образе, он будет огромным, медленным и небезопасным.


# Как работает Multi-stage?
Вы **используете инструкцию FROM несколько раз внутри одного Dockerfile**. Каждый блок FROM — это новый этап (stage). Вы можете копировать файлы из одного этапа в другой, а в финальный образ попадет только то, что вы перенесли в последний блок.

# Пример:
```yaml
# ЭТАП 1: Сборка (называем его "builder")
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY . .
# Компилируем бинарный файл
RUN go build -o myapp main.go

# ЭТАП 2: Финальный образ (минимальный)
FROM alpine:latest
WORKDIR /root/
# Копируем ТОЛЬКО один исполняемый файл из первого этапа
COPY --from=builder /app/myapp .

# Запускаем
CMD ["./myapp"]
```

**Результат:**
- Этап builder весил ~300 МБ.
- Итоговый образ на alpine весит ~10 МБ.
- Итог: Экономия места и безопасности (в финальном образе нет даже компилятора Go).

# Как использовать артефакты из чужих образов?
Вы можете копировать файлы даже не из своих этапов, а из любых готовых образов:

COPY **--from=nginx:latest** /etc/nginx/nginx.conf /my/local/path